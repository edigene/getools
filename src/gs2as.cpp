#include "gs2as.h"

void ctg_t::cmp_seqnn(double edeff, int64_t totr){
    seqnn.clear();
    seqps[0] = .0;
    double ttedef = .0;
    for(auto& e: seqps) ttedef += e;
    double xfold = edeff/ttedef;
    seqps[0] = 1-edeff;
    for(size_t i = 1; i < seqps.size(); ++i) seqps[i] = xfold * seqps[i];
    int64_t stxr = 0;
    for(size_t i = 0; i < seqps.size(); ++i){
        seqnn.push_back(seqps[i] * totr);
        stxr += seqnn[i];
    }
    if(stxr < totr){
        if(seqnn.size() == 1) seqnn[0] += totr-stxr;
        else seqnn[1] += totr-stxr;
    }
}

void ctg_t::out_seqs(std::ofstream& fw, bool details){
    int64_t ttr = 0;
    for(auto& e: seqnn) ttr += e;
    for(size_t i = 0; i < seqns.size(); ++i){
        if(details){
            fw << refn << "\t";
            fw << (double)seqnn[i]/(double)ttr << "\t";
        }
        fw << seqns[i] << "\t";
        fw << seqnn[i] << "\t";
        fw << seqss[i] << "\n";
    }
}

bool gs2as_opt_t::valid(){
    if(igtntsv.empty() || (!util::exists(igtntsv))){
        fprintf(stderr, "topN mutated sequence table(gtn.tsv) generated by getools bcf2fa must be provided\n");
        return false;
    }
    if(edeff < 0 || edeff > 1 || totr < 0){
        fprintf(stderr, "valid positive edit efficience and total reads must be provided \n");
        return false;
    }
    return true;
}

void gs2as_opt_t::gs2as(){
    std::ofstream fw(ogsntsv);
    std::ofstream fx(ogsdtsv);
    std::string line;
    util::LineReader lr(igtntsv);
    lr.getline(line);
    std::vector<std::string> vstr;
    ctg_t* pt = new ctg_t();
    std::string lcn;
    while(lr.getline(line)){
        util::split(line, vstr, "\t");
        if(lcn.empty()){
            pt->refn = vstr[0];
            lcn = vstr[0];
        }
        if(vstr[0] == lcn){
            pt->seqns.push_back(vstr[1]);
            pt->seqps.push_back(atof(vstr[2].c_str()));
            pt->seqss.push_back(vstr[3]);
        }else{
            pt->cmp_seqnn(edeff, totr);
            pt->out_seqs(fw);
            pt->out_seqs(fx, true);
            pt->seqns.clear();
            pt->seqss.clear();
            pt->seqps.clear();
            pt->refn = vstr[0];
            lcn = vstr[0];
            pt->seqns.push_back(vstr[1]);
            pt->seqps.push_back(atof(vstr[2].c_str()));
            pt->seqss.push_back(vstr[3]);
        }
    }
    pt->cmp_seqnn(edeff, totr);
    pt->out_seqs(fw);
    pt->out_seqs(fx, true);
    delete pt;
    fw.close();
    fx.close();
}

void gs2as_usage(gs2as_opt_t* opt, char* arg0){
    fprintf(stderr, "\n");
    fprintf(stderr, "Usage: %s %s [options]\n\n", PACKAGE_NAME, arg0);
    fprintf(stderr, "Options:  -i FILE   input topN mutated sequence table generated by getools bcf2fa(gtn.tsv)\n");
    fprintf(stderr, "          -s STR    output simple tsv path [%s]\n", opt->ogsntsv.c_str());
    fprintf(stderr, "          -d STR    output detailed tsv path [%s]\n", opt->ogsdtsv.c_str());
    fprintf(stderr, "          -n INT    total reads to simulate [%lld]\n", opt->totr);
    fprintf(stderr, "          -e FLOAT  edit efficience to simulate [%f]\n", opt->edeff);
    fprintf(stderr, "\n");
}

int gs2as_main(int argc, char** argv){
    gs2as_opt_t opt;
    if(argc == 1){
        gs2as_usage(&opt, argv[0]);
        return 0;
    }
    int c = 0;
    while((c = getopt(argc, argv, "i:s:d:n:e:h")) >= 0){
        switch(c){
            case 'i': opt.igtntsv = optarg; break;
            case 's': opt.ogsntsv = optarg; break;
            case 'd': opt.ogsdtsv = optarg; break;
            case 'n': opt.totr= atol(optarg); break;
            case 'e': opt.edeff = atof(optarg); break;
            case 'h': gs2as_usage(&opt, argv[0]); return 0; break;
            default: break;
        }
    }
    if(opt.valid()){
        opt.gs2as();
        return 0;
    }else{
        return 1;
    }
}
