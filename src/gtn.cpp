#include "gtn.h"

void gtn_usage(gtn_opt_t* opt, char* arg0){
    fprintf(stderr, "\n");
    fprintf(stderr, "Usage: %s %s [options]\n\n", PACKAGE_NAME, arg0);
    fprintf(stderr, "Options:  -i FILE  input bcf file list in TSV format(col1:name,col2:path)\n");
    fprintf(stderr, "          -o STR   output file name prefix\n");
    fprintf(stderr, "          -a STR   amplicon name to do analysis\n");
    fprintf(stderr, "          -b INT   beg position of edited range(1 based inclusive)\n");
    fprintf(stderr, "          -e INT   end position of edited range(1 based invlusive)\n");
    fprintf(stderr, "          -r FLOAT min ref freq needed for wild type cell [%f]\n", opt->mrv);
    fprintf(stderr, "          -m FLOAT min ref freq needed for hetero wild/mut cell [%f]\n", opt->mxv);
    fprintf(stderr, "          -n INT   number of top shared variants to compare [%d]\n", opt->topn);
    fprintf(stderr, "          -v INT   variant type to compare(1:SNV,2:INS,4:DEL,8:DELINS) [%d]\n", opt->type);
    fprintf(stderr, "          -c FILE  color system for each variant\n");
    fprintf(stderr, "          -9 FILE  js/css cdn configure json file\n");
    fprintf(stderr, "          -w INT   html topN shared variants graph width [%d]px\n", opt->hw);
    fprintf(stderr, "          -z INT   dimension reduction method(%d:%s,%d:%s,%d:%s) [%d]\n",
                                        DR_METHOD_NONE, DR_METHOD2STR_ARR[DR_METHOD_NONE],
                                        DR_METHOD_PCA, DR_METHOD2STR_ARR[DR_METHOD_PCA],
                                        DR_METHOD_UMAP, DR_METHOD2STR_ARR[DR_METHOD_UMAP],
                                        opt->drmethod);
    fprintf(stderr, "          -u       compare all unique variants instead of topN if set\n");
    fprintf(stderr, "          -x       show sample names in dimension reduction graph if set\n");
    fprintf(stderr, "          -y       calculate genotype of each amplicon if set\n");
    fprintf(stderr, "\n");
}

int gtn_main(int argc, char** argv){
    gtn_opt_t opt;
    if(argc == 1){
        gtn_usage(&opt, argv[0]);
        return 0;
    }
    int c = 0;
    while((c = getopt(argc, argv, "i:o:a:b:e:r:m:n:v:c:9:w:z:uxyh")) >= 0){
        switch(c){
            case 'i': opt.inlist = optarg; break;
            case 'o': opt.outpre = optarg; break;
            case 'a': opt.amp = optarg; break;
            case 'b': opt.beg = atoi(optarg); break;
            case 'e': opt.end = atoi(optarg); break;
            case 'r': opt.mrv = atof(optarg); break;
            case 'm': opt.mxv = atof(optarg); break;
            case 'n': opt.topn = atoi(optarg); break;
            case 'v': opt.type = atoi(optarg); break;
            case 'c': opt.colsys = optarg; break;
            case '9': opt.hrjsn = optarg; break;
            case 'w': opt.hw = atoi(optarg); break;
            case 'z': opt.drmethod = atoi(optarg); break;
            case 'u': opt.uniqa = true; break;
            case 'x': opt.showt = true; break;
            case 'y': opt.calg = true; break;
            case 'h': gtn_usage(&opt, argv[0]); return 0; break;
            default: break;
        }
    }
    if(opt.inlist == NULL || opt.outpre == NULL){
        fprintf(stderr, "input/output must be provided\n");
        return 0;
    }
    if(!opt.amp){
        fprintf(stderr, "amplicon name must be provided\n");
        return 0;
    }
    if(opt.colsys){
        util::makeMapPairFromFileByLine(opt.colsys, opt.colmap, "\t");
        auto iter = opt.colmap.find(opt.unknownkey);
        if(iter == opt.colmap.end()){
            fprintf(stderr, "%s color must be provided in color system\n", opt.unknownkey.c_str());
            return 0;
        }else{
            opt.colunknown = iter->second;
        }
        iter = opt.colmap.find(opt.otherkey);
        if(iter == opt.colmap.end()){
            fprintf(stderr, "%s color must be provided in color system\n", opt.otherkey.c_str());
            return 0;
        }else{
            opt.colother = iter->second;
        }
    }
    opt.hmo.init(opt.hrjsn);
    return opt.cons_ana();
}

int gtn_opt_t::cons_ana(){
    int pret = parse_bcfs();
    if(pret) return pret;
    ana8js();
    ana8R();
    return 0;
}

int gtn_opt_t::parse_bcfs(){
    bool prvalid = false;
    // range limit test
    if(beg >= 0 && end > beg){
        prvalid = true;
    }
    // parse all input, only keep deletion and insertion
    std::vector<std::string> vstr;
    util::LineReader linr(inlist);
    std::string line;
    int gnci = 0;
    while(linr.getline(line)){
        util::split(line, vstr, "\t");
        if(vstr.size() < 1){
            fprintf(stderr, "input list must be a 2 column TSV(col1: sample name, col2: edit details file path generated by getools or 1 column for group name\n");
            return 1;
        }
        if(vstr.size() == 1){
            for(int i = 0; i <= gnci; ++i){
                sid2grp.push_back(vstr[0]);
                sidngrp.push_back(std::to_string(grps.size()));
            }
            if(calg) gttype.push_back(GEVAR_OTH);
            gtnacc.push_back(std::vector<double>());
            samples.push_back(vstr[0]);
            grps.push_back(vstr[0]);
            grns.push_back(gnci);
            sgrps.insert(vstr[0]);
            gnci = 0;
            edieff.push_back(.0); recpef.push_back(.0); receff.push_back(.0); reeeff.push_back(.0); muteff.push_back(.0);
            totcnt.push_back(0); rawcnt.push_back(0); recstat.push_back(0);
            continue;
        }
        ++gnci;
        samples.push_back(vstr[0]);
        htsFile* fp = bcf_open(vstr[1].c_str(), "r");
        hts_idx_t* idx = bcf_index_load(vstr[1].c_str());
        bcf_hdr_t* hdr = bcf_hdr_read(fp);
        int tid = bcf_hdr_name2id(hdr, amp);
        int cid = bcf_hdr_id2int(hdr, BCF_DT_CTG, amp);
        int hidx = -1;
        bcf_hrec_t* hrec = bcf_hdr_id2hrec(hdr, BCF_DT_CTG, BCF_HL_CTG, cid);
        if(!prvalid){
            hidx = bcf_hrec_find_key(hrec, "geb");
            beg = atoi(hrec->vals[hidx]);
            hidx = bcf_hrec_find_key(hrec, "gee");
            end = atoi(hrec->vals[hidx]);
            prvalid = true;
        }
        {
            hidx = bcf_hrec_find_key(hrec, "rawcnt");
            if(hidx >= 0) rawcnt.push_back(atof(hrec->vals[hidx]));
            else rawcnt.push_back(.0);
            hidx = bcf_hrec_find_key(hrec, "totcnt");
            if(hidx >= 0) totcnt.push_back(atof(hrec->vals[hidx]));
            else totcnt.push_back(.0);
            hidx = bcf_hrec_find_key(hrec, "recstat");
            if(hidx >= 0) recstat.push_back(atof(hrec->vals[hidx]));
            else recstat.push_back(0);
            hidx = bcf_hrec_find_key(hrec, "edieff");
            if(hidx >= 0) edieff.push_back(atof(hrec->vals[hidx]));
            else edieff.push_back(.0);
            if(recstat[recstat.size()-1]){
                hidx = bcf_hrec_find_key(hrec, "recpef");
                if(hidx >= 0) recpef.push_back(atof(hrec->vals[hidx]));
                else recpef.push_back(.0);
                hidx = bcf_hrec_find_key(hrec, "receff");
                if(hidx >= 0) receff.push_back(atof(hrec->vals[hidx]));
                else receff.push_back(.0);
                hidx = bcf_hrec_find_key(hrec, "reeeff");
                if(hidx >= 0) reeeff.push_back(atof(hrec->vals[hidx]));
                else reeeff.push_back(.0);
            }else{
                recpef.push_back(.0); receff.push_back(.0); reeeff.push_back(.0);
            }
            hidx = bcf_hrec_find_key(hrec, "muteff");
            if(hidx >= 0) muteff.push_back(atof(hrec->vals[hidx]));
            else muteff.push_back(.0);
        }
        hts_itr_t* itr = bcf_itr_queryi(idx, tid, beg, end);
        bcf1_t* b = bcf_init1();
        int* vtv = NULL; float* afv = NULL; int* adv = NULL;
        int nvt = 0, naf = 0, nad = 0;
        int nsmp = bcf_hdr_nsamples(hdr);
        std::vector<variant_t*> tvars;
        while(bcf_itr_next(fp, itr, b) >= 0){
            bcf_unpack(b, BCF_UN_INFO);
            if(bcf_get_info_int32(hdr, b, "VT", &vtv, &nvt) > 0){
                if(vtv[0] & type){
                    bcf_unpack(b, BCF_UN_ALL);
                    bcf_get_format_float(hdr, b, "AF", &afv, &naf);
                    bcf_get_format_int32(hdr, b, "AD", &adv, &nad);
                    for(int a = 0; a < b->n_allele-1; ++a){
                        if(nsmp == 1 ||
                           (adv[a] > 0 && adv[nsmp*b->n_allele+a] < nctc)){
                            variant_t* v = new variant_t();
                            v->ref = b->d.allele[0];
                            v->alt = b->d.allele[a+1];
                            v->freq = afv[a];
                            v->count = adv[a];
                            v->start = b->pos+1;
                            if(vtv[0] & (GEVAR_DEL | GEVAR_DIN)){
                                v->end = v->start + v->ref.size()-1;
                                v->start += 1;
                            }else if(vtv[0] & (GEVAR_SNV | GEVAR_INS)){
                                v->end = v->start;
                            }
                            v->width = (int)v->alt.size()-(int)v->ref.size();
                            v->type = GEV_STR_ARR[vtv[0]];
                            v->ntype = vtv[0];
                            v->sidx = samples.size() - 1;
                            v->isgtn = 0;
                            vars.push_back(v);
                            tvars.push_back(v);
                        }
                    }
                }
            }
        }
        std::sort(tvars.begin(), tvars.end(), VarSortByFreq());
        std::vector<double> accfr;
        if(tvars.size()){
            double inifr = tvars[0]->freq;
            accfr.push_back(inifr);
            for(size_t xci = 1; xci < tvars.size(); ++xci){
                inifr += tvars[xci]->freq;
                accfr.push_back(inifr);
            }
        }
        gtnacc.push_back(accfr);
        if(calg) gttype.push_back(call_gt(tvars, edieff[edieff.size()-1]));
        for(auto& e: tvars) e = NULL;
        tvars.clear();
        if(afv){ free(afv); afv = NULL; }
        if(adv){ free(adv); adv = NULL; }
        if(vtv){ free(vtv); vtv = NULL; }
        bcf_close(fp);
        hts_idx_destroy(idx);
        bcf_hdr_destroy(hdr);
        hts_itr_destroy(itr);
        bcf_destroy(b);
    }
    // update rechdr
    needrec = 0;
    for(auto& e: recstat){
        if(e){
            needrec = 1;
            break;
        }
    }
    if(grns.size()) samples.resize(samples.size()-1);
    fprintf(stderr, "Total vars: %lu\n", vars.size());
    // sort by type
    std::sort(vars.begin(), vars.end(), VarSortByType());
    // make variant id(same var share same id)
    vars[0]->varid = lastid;
    int shn = 1;
    double shf = vars[0]->freq;
    sumaf.resize(samples.size(), .0);
    for(size_t j = 1; j < vars.size(); ++j){
        sumaf[vars[j]->sidx] += vars[j]->freq;
        if(vars[j]->same_var(vars[j-1])){
            vars[j]->varid = lastid;
            shf += vars[j]->freq;
            ++shn;
        }else{
            sharen.push_back(shn);
            sharef.push_back(shf);
            ++lastid;
            shn = 1;
            shf = vars[j]->freq;
            vars[j]->varid = lastid;
        }
    }
    if(uniqa || lastid+1 < topn) topn = lastid + 1;
    sharen.push_back(shn);
    sharef.push_back(shf);
    for(size_t i = 0; i < sharef.size(); ++i){
        sharef[i] = sharef[i]/sharen[i];
    }
    for(size_t j = 0; j < vars.size(); ++j){
        vars[j]->sfreq = sharef[vars[j]->varid];
    }
    maxaf = .0;
    for(auto& e: sumaf){
        if(e > maxaf) maxaf = e;
    }
    nsamples = samples.size();
    psamples = grns.empty() ? samples.size() : samples.size()-grns.size()+1;
    nallele = topn;
    pa4s = (double**)malloc(nsamples*sizeof(double*));
    for(int i = 0; i < nsamples; ++i){
        pa4s[i] = (double*)calloc(nallele, sizeof(double));
    }
    return 0;
}

void gtn_opt_t::ana8js(){
    std::sort(vars.begin(), vars.end(), VarSortByShareFreqAndType());
    kstring_t* s = (kstring_t*)calloc(1, sizeof(kstring_t));
    html2head(s);
    html2body(s);
    html2foot(s);
    kstring_t ks = {0, 0, 0};
    ksprintf(&ks, "%s.gtn.html", outpre);
    FILE* fp = fopen(ks.s, "w");
    fwrite(s->s, sizeof(char), s->l, fp);
    fclose(fp);
    free(ks.s);
    free(s->s);
    free(s);
}

void gtn_opt_t::ana8R(){
    // make mask array mask[var.id] = 1 if var is in topN sort by freq
    std::vector<uint8_t> mask(lastid+1, 0);
    // make id-convert array idca[var.id] = j if var is of top j sort by freq
    std::vector<int32_t> idca(lastid+1, 0);
    // legend
    std::vector<std::string> legend(lastid+1, "");
    kstring_t* sl = (kstring_t*)calloc(1, sizeof(kstring_t));
    kputs("sl<-c(", sl);
    int ttt = 0, topc = 0;
    // mask topn
    std::vector<std::string> vcols;
    std::string tnf = std::string(outpre) + ".name";
    FILE* ftnf = fopen(tnf.c_str(), "w");
    kstring_t vs = {0, 0, 0};
    for(size_t j = 0; j < vars.size(); ++j){
        if(!vars[j]->isgtn) break;
        if(mask[vars[j]->varid] == 0){
            ++topc;
            mask[vars[j]->varid] = 1;
            idca[vars[j]->varid] = ++ttt;
            vs.l = 0;
            ksprintf(&vs, "[%d,%d]:%+d", vars[j]->start, vars[j]->end, vars[j]->width);
            fwrite(vs.s, sizeof(char), vs.l, ftnf);
            fputc('\n', ftnf);
            if(colsys){
                auto iter = colmap.find(vs.s);
                if(iter == colmap.end()){
                    vcols.push_back(colunknown);
                }else{
                    vcols.push_back(iter->second);
                }
            }
            ksprintf(sl, "\"%s\",", vs.s);
        }
    }
    fclose(ftnf);
    if(vs.s) free(vs.s);
    if(colsys) vcols.push_back(colother);
    kputs("\"others\")", sl);
    fprintf(stderr, "total %d uniq variant got for top%d\n", ttt, topn);
    // output file, vars and accumulate vars to compute others
    kstring_t* ss = (kstring_t*)calloc(1, sizeof(kstring_t)); // Samples
    kstring_t* sv = (kstring_t*)calloc(1, sizeof(kstring_t)); // VarID
    kstring_t* sa = (kstring_t*)calloc(1, sizeof(kstring_t)); // assign cmds
    kputs("s<-c(", ss);
    kputs("v<-c(", sv);
    std::vector<double> vafacc(samples.size(), 0);
    std::vector<double> otherf(samples.size(), 0);
    std::vector<int64_t> othern(samples.size(), 0);
    kstring_t tmpstr = {0, 0, 0};
    ksprintf(&tmpstr, "%s.tsv", outpre);
    FILE* fp = fopen(tmpstr.s, "w");
    variant_t::out_head(fp);
    for(size_t j = 0; j < vars.size(); ++j){
        if(mask[vars[j]->varid]){
            vars[j]->varid = idca[vars[j]->varid];
            vars[j]->out_rec(fp, samples);
            vafacc[vars[j]->sidx] += vars[j]->freq;
            ksprintf(ss, "'%s',", samples[vars[j]->sidx].c_str());
            ksprintf(sv, "%d,", vars[j]->varid);
            ksprintf(sa, "vt['%d','%s']<-%lf\n", vars[j]->varid, samples[vars[j]->sidx].c_str(), vars[j]->freq);
        }else{
            othern[vars[j]->sidx] += vars[j]->count;
            otherf[vars[j]->sidx] += vars[j]->freq;
        }
    }
    // output tsv file, others
    variant_t tv;
    int nzs = 0;
    int xzs = -1;
    for(size_t i = 0; i < vafacc.size(); ++i){
        tv.varid = ttt+1;
        tv.sidx = i;
        tv.count = othern[i];
        tv.freq = otherf[i];
        tv.type = GEV_STR_ARR[GEVAR_OTH];
        tv.out_rec(fp, samples);
        ksprintf(ss, "'%s',", samples[tv.sidx].c_str());
        ksprintf(sv, "%d,", tv.varid);
        ksprintf(sa, "vt['%d','%s']<-%lf\n", tv.varid, samples[tv.sidx].c_str(), tv.freq);
        if(tv.count > 0 && tv.freq > .0) nzs = tv.sidx;
    }
    if(xzs >= 0) nzs = xzs;
    ss->s[ss->l-1] = ')';
    sv->s[sv->l-1] = ')';
    fprintf(stderr, "total %d variants of shared top %d in %lu samples\n", topc, topn, samples.size());
    fclose(fp);
    // plot in R
    kstring_t* sr = ss;
    kputc('\n', sr);
    kputsn(sv->s, sv->l, sr); free(sv->s);
    kputc('\n', sr);
    kputs("vt<-table(v,s)\n", sr);
    kputsn(sa->s, sa->l, sr); free(sa->s);
    ksprintf(sr, "tot<-vt[nrow(vt), '%s']\n", samples[nzs].c_str());
    ksprintf(sr, "vt[nrow(vt), '%s']<-2.0\n", samples[nzs].c_str());
    ksprintf(sr, "rowidx<-order(vt[, '%s'])\n", samples[nzs].c_str());
    ksprintf(sr, "vt[nrow(vt), '%s']<-tot\n", samples[nzs].c_str());
    ksprintf(sr, "vt<-vt[,c(");
    for(size_t i = 0; i < samples.size(); ++i){
        ksprintf(sr, "'%s',", samples[i].c_str());
    }
    sr->s[sr->l-1] = ')';
    ksprintf(sr, "]\n");
    if(grns.size()){
        ksprintf(sr, "grpn<-c(");
        for(size_t i = 0; i < grns.size(); ++i) ksprintf(sr, "%d,", grns[i]);
        sr->s[sr->l-1] =')';
        ksprintf(sr, "\n");
        ksprintf(sr, "grps<-c(");
        for(size_t i = 0; i < grps.size(); ++i) ksprintf(sr, "'%s',", grps[i].c_str());
        sr->s[sr->l-1] =')';
        ksprintf(sr, "\n");
        ksprintf(sr, "colnames(vt)<-c(");
        for(size_t i = 0; i < samples.size(); ++i){
            if(sgrps.find(samples[i]) != sgrps.end()){
                ksprintf(sr, "' ',");
            }else{
                ksprintf(sr, "'%s',", samples[i].c_str());
            }
        }
        sr->s[sr->l-1] =')';
        ksprintf(sr, "\n");
    }
    kputs("vt<-as.matrix(vt)\n", sr);
    kputs("vt<-vt[rowidx,]\n", sr);
    kputs("vt<-as.matrix(vt)\n", sr);
    if(samples.size() > 100) width = 0.125 * samples.size();
    ksprintf(sr, "pdf(\"%s.pdf\", width=%d, height=%d)\n", outpre, width, height);
    ksprintf(sr, "layout(matrix(c(1,2), nrow = 1), widths = c(%f, %f))\n", lr, rr);
    ksprintf(sr, "par(mar = c(5, 4, 4, 0))\n");
    if(colsys){
        ksprintf(sr, "mcol <- c(");
        for(size_t i = 0; i < vcols.size(); ++i){
            ksprintf(sr, "'%s',", vcols[i].c_str());
        }
        sr->s[sr->l-1] = ')';
        ksprintf(sr, "\n");
        ksprintf(sr, "mcol <- mcol[rowidx]\n");
    }else{
        ksprintf(sr, "mcol <- rainbow(%d)\n", ttt+1);
        ksprintf(sr, "set.seed(42)\n");
        ksprintf(sr, "mcol <- sample(mcol)\n");
        ksprintf(sr, "mcol <- mcol[rowidx]\n");
    }
    kputs("bx<-barplot(vt, ", sr);
    ksprintf(sr, "cex.main=1.0, ");
    ksprintf(sr, "ylim=c(0, %lf),", maxaf);
    if(grns.size()){
        ksprintf(sr, "main=\"Edit Product Frequency From Top%d Shared Indels across %lu Samples in %lu Groups\", ",
                topn, samples.size()-grns.size()+1, grns.size());
        ksprintf(sr, "xlab=\"Samples and Groups\", las=2, cex.names=.5, ylab=\"Edit Product Frequency\", col=mcol)\n");
    }else{
        ksprintf(sr, "main=\"Edit Product Frequency From Top%d Shared Indels Across %lu Samples\", ", topn, samples.size());
        ksprintf(sr, "xlab=\"Samples\", las=2, cex.names=.5, ylab=\"Edit Product Frequency\", col=mcol)\n");
    }
    if(grns.size()){
        ksprintf(sr, "mx<-c()\n");
        ksprintf(sr, "ci<-c()\n");
        ksprintf(sr, "ci<-append(ci, max(1, as.integer(grpn[1]/2)))\n");
        ksprintf(sr, "si<-grpn[1]\n");
        ksprintf(sr, "for(i in 2:length(grpn)){\n");
        ksprintf(sr, "  si <- si + 1\n");
        ksprintf(sr, "  ct <- max(1, as.integer(grpn[i]/2))\n");
        ksprintf(sr, "  ci<-append(ci, si+ct)\n");
        ksprintf(sr, "  si <- si + grpn[i]\n");
        ksprintf(sr, "}\n");
        ksprintf(sr, "for(i in 1:length(grpn)){\n");
        ksprintf(sr, "  if(grpn[i] == 1){\n");
        ksprintf(sr, "    mtext(paste(grps[i], '(', grpn[i], ')', sep=''), side=1, line=2, at=bx[ci[i]])\n");
        ksprintf(sr, "  }else{\n");
        ksprintf(sr, "    mtext(paste(grps[i], '(', grpn[i], ')', sep=''), side=1, line=2, at=bx[ci[i]]+(bx[ci[i]+1]-bx[ci[i]])*0.5)\n");
        ksprintf(sr, "  }\n");
        ksprintf(sr, "}\n");
    }
    ksprintf(sr, "par(mar = c(5, 0, 4, 1))\n");
    ksprintf(sr, "plot(1:3, rnorm(3), pch = 1, lty = 1, ylim=c(-2,2), type = \"n\", axes = FALSE, ann = FALSE)\n");
    ksprintf(sr, "%s\n", sl->s);
    ksprintf(sr, "sl<-rev(sl[rowidx])\n");
    ksprintf(sr, "legend(\"left\", bty='n', xpd=T, inset=c(0, 0), fill = rev(mcol), ncol = 2, cex = 0.5,");
    ksprintf(sr, "legend=sl)\n");
    kputs("dev.off()\n", sr);
    // write Rscript
    tmpstr.l = 0;
    ksprintf(&tmpstr, "%s.R", outpre);
    fp = fopen(tmpstr.s, "w");
    fwrite(sr->s, sizeof(char), sr->l, fp); free(sr->s);
    fclose(fp);
    // do plot
    kstring_t rcmd = {0, 0, 0};
    ksprintf(&rcmd, "Rscript %s", tmpstr.s);
    system(rcmd.s);
    // release resources
    free(tmpstr.s);
    free(rcmd.s);
    free(sr);
    free(sa);
}

void gtn_opt_t::html2head(kstring_t* s){
    hmo.html2head(s, "gtn");
}

void gtn_opt_t::html2body(kstring_t* s){
    // Summary beg
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('summary')><a name='summary'>Summary</a></div>\n");
    ksprintf(s, "<div id='summary'>\n");
    // Summary -> Samples beg
    ksprintf(s, "<div class='subsection_title' onclick=showOrHide('general')>Sample Information</div>\n");
    ksprintf(s, "<div id='smps'>\n");
    ksprintf(s, "<table class='summary_table'>\n");
    {
        // samples
        ksprintf(s, "<tr>");
        ksprintf(s, "<td class='col1'>samples</td>");
        if(grps.size()) ksprintf(s, "<td class='col2'>%ld</td>", samples.size()-grps.size()+1);
        else ksprintf(s, "<td class='col2'>%ld</td>", samples.size());
        ksprintf(s, "</tr>");
        // groups
        ksprintf(s, "<tr>");
        ksprintf(s, "<td class='col1'>groups</td>");
        ksprintf(s, "<td class='col2'>%ld</td>", grps.size());
        ksprintf(s, "</tr>");
        // total vars
        ksprintf(s, "<tr>");
        ksprintf(s, "<td class='col1'>total variants</td>");
        ksprintf(s, "<td class='col2'>%ld</td>", vars.size());
        ksprintf(s, "</tr>");
        // uniq vars
        ksprintf(s, "<tr>");
        ksprintf(s, "<td class='col1'>unique variants</td>");
        ksprintf(s, "<td class='col2'>%d</td>", lastid+1);
        ksprintf(s, "</tr>");
    }
    ksprintf(s, "</table>\n");
    ksprintf(s, "</div>\n");
    // Summary -> Samples end
    ksprintf(s, "</div>\n");
    ksprintf(s, "</div>\n");
    // Summary end
    // Edeff beg
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('edefft')><a name='edefft'>Edit summary of %s across samples </a></div>\n", amp);
    ksprintf(s, "<div id='edefft'>\n");
    ksprintf(s, "<table class='summary_table' id='edefft_table'>\n");
    {
        // head
        ksprintf(s, "<thead>\n");
        ksprintf(s, "<tr><th class='col1'>Sample</th>");
        ksprintf(s, "<th class='col2'>EditedRate</th>");
        if(needrec){
            ksprintf(s, "<th class='col2'>TotalRecombRate</th>");
            ksprintf(s, "<th class='col2'>ExactRecombRate</th>");
            ksprintf(s, "<th class='col2'>RecombHitRate</th>");
        }
        ksprintf(s, "<th class='col2'>OverallMutatedRate</th>");
        if(calg){
            ksprintf(s, "<th class='col2'>Genotype</th>");
        }
        ksprintf(s, "<th class='col2'>QualifiedSeqs</th>");
        ksprintf(s, "<th class='col2'>RawSeqs</th></tr>\n");
        ksprintf(s, "</thead>\n");
        // body
        ksprintf(s, "<tbody>\n");
        for(size_t u = 0 ; u < samples.size(); ++u){
            if(sgrps.find(samples[u]) == sgrps.end()){
                ksprintf(s, "<tr>");
                ksprintf(s, "<td class='col2'>%s</td>", samples[u].c_str());
                ksprintf(s, "<td class='col2'>%lf</td>", edieff[u]);
                if(needrec){
                    ksprintf(s, "<td class='col2'>%lf</td>", receff[u]);
                    ksprintf(s, "<td class='col2'>%lf</td>", reeeff[u]);
                    ksprintf(s, "<td class='col2'>%lf</td>", recpef[u]);
                }
                ksprintf(s, "<td class='col2'>%lf</td>", muteff[u]);
                if(calg){
                    ksprintf(s, "<td class='col2'>%s</td>", GT_INT2STR_ARR[gttype[u]]);
                }
                ksprintf(s, "<td class='col2'>%lld</td>", totcnt[u]);
                ksprintf(s, "<td class='col2'>%lld</td>", rawcnt[u]);
                ksprintf(s, "</tr>");
            }
        }
        ksprintf(s, "</tbody></table>\n");
        hmo.printExportButtons(s, "edefft_table", "amp.edit.rate");
    }
    ksprintf(s, "</div>\n");
    ksprintf(s, "</div>\n");
    // Edeff end
    // Plot beg
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('gtngid')><a name='gtngid'>Barplot of shared variants across samples</a></div>\n");
    ksprintf(s, "<div id='gtngid'>\n");
    ksprintf(s, "<div class='sub_section_tips alert'><p style='color:red'>the accumulated frequency might be greater than the edited rate of each amplicons due to some amplicons might be edited more than once</p></div>\n");
    ksprintf(s, "<div id='plot_gtngid'></div>\n");
    ksprintf(s, "</div>\n");
    ksprintf(s, "\n<script type=\"text/javascript\">\n");
    size_t j = 0;
    int txid = vars[0]->varid;
    kstring_t* ts1 = (kstring_t*)calloc(1, sizeof(kstring_t));
    kstring_t* tsg = (kstring_t*)calloc(1, sizeof(kstring_t));
    kstring_t* ts2 = (kstring_t*)calloc(1, sizeof(kstring_t));
    kstring_t* t4g = (kstring_t*)calloc(1, sizeof(kstring_t));
    kstring_t* tst = (kstring_t*)calloc(1, sizeof(kstring_t));
    kstring_t* p4g = (kstring_t*)calloc(1, sizeof(kstring_t));
    int maxn = MIN(lastid+1, topn);
    std::vector<double> tfreq(samples.size(), 0);
    for(int i = 0; i < maxn; ++i){
        txid = vars[j]->varid;
        ksprintf(s, "var trace%d = {\n", i);
        if(calg) ksprintf(p4g, "var trace%d = {\n", i);
        ksprintf(s, "  type: 'bar',\n");
        if(calg) ksprintf(p4g, "  type: 'bar',\n");
        ksprintf(s, "  hoverinfo: 'x+name+y',\n");
        if(calg) ksprintf(s, "  hoverinfo: 'x+name+y',\n");
        ksprintf(s, "  name: '[%d,%d]:%+d',\n", vars[j]->start, vars[j]->end, vars[j]->width);
        if(calg) ksprintf(p4g, "  name: '[%d,%d]:%+d',\n", vars[j]->start, vars[j]->end, vars[j]->width);
        { // for table
            ksprintf(tst, "<tr>");
            ksprintf(tst, "<td class='col2'>%s</td>", amp);
            ksprintf(tst, "<td class='col2'>%d</td>", vars[j]->start);
            ksprintf(tst, "<td class='col2'>%d</td>", vars[j]->end);
            ksprintf(tst, "<td class='col2'>%s</td>", vars[j]->type.c_str());
            ksprintf(tst, "<td class='col2'>%s</td>", vars[j]->ref.c_str());
            ksprintf(tst, "<td class='col2'>%s</td>", vars[j]->alt.c_str());
            ksprintf(tst, "<td class='col2'>%d</td>", vars[j]->width);
        }
        for(auto& e: tfreq) e = 0;
        int ttnz = 0;
        while(j < vars.size() && vars[j]->varid == txid){
            vars[j]->isgtn = 1;
            tfreq[vars[j]->sidx] = vars[j]->freq;
            ++j;
            ++ttnz;
        }
        ksprintf(tst, "<td class='col2'>%d</td>", ttnz);
        ts1->l = ts2->l = tsg->l = t4g->l = 0;
        for(size_t u = 0; u < samples.size(); ++u){
            if(sgrps.find(samples[u]) == sgrps.end()){ // for table
                if(i < nallele) pa4s[u][i] = tfreq[u];
                ksprintf(ts2, "%lf,", tfreq[u]);
                ksprintf(tst, "<td class='col2'>%lf</td>", tfreq[u]);
                ksprintf(ts1, "'%s',", samples[u].c_str());
                if(sgrps.size()) ksprintf(tsg, "'%s',", sid2grp[u].c_str());
                if(calg) ksprintf(t4g, "'%s',", GT_INT2STR_ARR[gttype[u]]);
            }
        }
        ksprintf(tst, "</tr>");
        if(sgrps.size()){
            ksprintf(s, "  x: [[%s],[%s]],\n", tsg->s, ts1->s);
        }else{
            ksprintf(s, "  x: [%s],\n", ts1->s);
        }
        if(calg) ksprintf(p4g, "  x: [[%s],[%s]],\n", t4g->s, ts1->s);
        ksprintf(s, "  y: [%s],\n", ts2->s);
        if(calg) ksprintf(p4g, "  y: [%s],\n", ts2->s);
        ksprintf(s, "};\n"); 
        if(calg) ksprintf(p4g, "};\n");
    }
    { // for table
        ksprintf(tst, "<tr>");
        ksprintf(tst, "<td class='col2'>%s</td>", amp);
        ksprintf(tst, "<td class='col2'>-</td>");
        ksprintf(tst, "<td class='col2'>-</td>");
        ksprintf(tst, "<td class='col2'>Others</td>");
        ksprintf(tst, "<td class='col2'>-</td>");
        ksprintf(tst, "<td class='col2'>-</td>");
        ksprintf(tst, "<td class='col2'>-</td>");
        ksprintf(tst, "<td class='col2'>-</td>");
    }
    otfreq.resize(samples.size(), .0);
    for(size_t k = j; k < vars.size(); ++k) otfreq[vars[k]->sidx] += vars[k]->freq;
    ksprintf(s, "var trace%d = {\n", maxn); 
    if(calg) ksprintf(p4g, "var trace%d = {\n", maxn);
    ksprintf(s, "  type: 'bar',\n");            
    if(calg) ksprintf(p4g, "  type: 'bar',\n"); 
    ksprintf(s, "  name: 'others',\n");     
    if(calg) ksprintf(p4g, "  name: 'others',\n");
    ksprintf(s, "  hoverinfo: 'x+name+y',\n");
    if(calg) ksprintf(p4g, "  hoverinfo: 'x+name+y',\n");
    ts1->l = ts2->l = tsg->l = t4g->l = 0;
    for(size_t z = 0; z < otfreq.size(); ++z){
        if(sgrps.find(samples[z]) == sgrps.end()){ // for table
            ksprintf(ts1, "'%s',", samples[z].c_str());
            ksprintf(ts2, "%lf,", otfreq[z]);
            ksprintf(tst, "<td class='col2'>%lf</td>", otfreq[z]);
            if(sgrps.size()) ksprintf(tsg, "'%s',", sid2grp[z].c_str());
            if(calg) ksprintf(t4g, "'%s',", GT_INT2STR_ARR[gttype[z]]);
        }
    }
    ksprintf(tst, "</tr>");
    if(sgrps.size()){
        ksprintf(s, "  x: [[%s],[%s]],\n", tsg->s, ts1->s);
    }else{
        ksprintf(s, "  x: [%s],\n", ts1->s);
    }
    if(calg) ksprintf(p4g, "  x: [[%s],[%s]],\n", t4g->s, ts1->s);
    ksprintf(s, "  y: [%s],\n", ts2->s); 
    if(calg) ksprintf(p4g, "  y: [%s],\n", ts2->s);
    ksprintf(s, "};\n");
    if(calg) ksprintf(p4g, "};\n");
    if(ts1->s){ free(ts1->s); free(ts1); }
    if(ts2->s){ free(ts2->s); free(ts2); }
    if(tsg->s){ free(tsg->s); free(tsg); }
    if(t4g->s){ free(t4g->s); free(t4g); }
    ksprintf(s, "var data = [");
    for(int i = maxn-1; i >= 0; --i){
        ksprintf(s, "trace%d,", i);
    }
    ksprintf(s, "trace%d,", maxn);
    ksprintf(s, "];\n");
    ksprintf(s, "var layout = {\n");
    ksprintf(s, "  title: 'Edit Product Frequency From Top%d Shared Indels Across %lu Samples',\n", topn, grns.empty() ? samples.size() : samples.size()-grns.size()+1);
    ksprintf(s, "  hovermode: 'closest',\n");
    ksprintf(s, "  barmode: 'stack',\n");
    ksprintf(s, "  height: %d,\n", MAX(800, MIN(800, maxn * 20)));
    ksprintf(s, "  width: %d,\n", hw);
    if(sgrps.size()){
        ksprintf(s, "  xaxis:{\n");
        ksprintf(s, "    automargin: true,\n");
        ksprintf(s, "    type: 'multicategory',\n");
        ksprintf(s, "    dtick: 1,\n");
        ksprintf(s, "    tickson: 'boundaries',\n");
        ksprintf(s, "    ticklen: 15,\n");
        ksprintf(s, "    showdividers: true,\n");
        ksprintf(s, "    dividercolor: 'grey',\n");
        ksprintf(s, "    dividerwidth: 2,\n");
        ksprintf(s, "    title: {\n");
        ksprintf(s, "      text: 'samples and groups',\n");
        ksprintf(s, "      standoff: 20,\n");
        ksprintf(s, "    },\n");
        ksprintf(s, "  },\n");
    }else{
        ksprintf(s, "  xaxis:{\n");
        ksprintf(s, "    automargin: true,\n");
        ksprintf(s, "    type: 'category',\n");
        ksprintf(s, "    dtick: 1,\n");
        ksprintf(s, "    title: {\n");
        ksprintf(s, "      text: 'samples',\n");
        ksprintf(s, "      standoff: 20,\n");
        ksprintf(s, "    },\n");
        ksprintf(s, "  },\n");
    }
    ksprintf(s, "  yaxis:{\n");
    ksprintf(s, "    automargin: true,\n");
    ksprintf(s, "    title: {\n");
    ksprintf(s, "      text: 'edit product frequency',\n");
    ksprintf(s, "      standoff: 20,\n");
    ksprintf(s, "    },\n");
    ksprintf(s, "  },\n");
    ksprintf(s, "};\n");
    ksprintf(s, "var config = {\n");
    ksprintf(s, "  toImageButtonOptions: {\n");
    ksprintf(s, "    format: 'svg',\n");
    ksprintf(s, "     filename: 'topn.shared.vars',\n");
    ksprintf(s, "     height: %d,\n", MAX(800, MIN(800, maxn * 20)));
    ksprintf(s, "     width: %d,\n", hw);
    ksprintf(s, "     scale: 1,\n");
    ksprintf(s, "  }\n");
    ksprintf(s, "};\n");
    ksprintf(s, "Plotly.newPlot(plot_gtngid, data, layout, config)\n");
    ksprintf(s, "</script>\n");
    ksprintf(s, "</div>\n");
    // Plot End
    // Plot group by genotype beg
    if(calg){
        ksprintf(s, "<div class='section_div'>\n");
        ksprintf(s, "<div class='section_title' onclick=showOrHide('gcalgid')><a name='gcalgid'>Barplot of shared variants across samples grouped by genotypes</a></div>\n");
        ksprintf(s, "<div id='gcalgid'>\n");
        ksprintf(s, "<div class='sub_section_tips alert'><p style='color:red'>the accumulated frequency might be greater than the edited rate of each amplicons due to some amplicons might be edited more than once</p></div>\n");
        ksprintf(s, "<div id='plot_gcalgid'></div>\n");
        ksprintf(s, "</div>\n");
        ksprintf(s, "\n<script type=\"text/javascript\">\n");
        ksprintf(s, "%s", p4g->s);
        ksprintf(s, "var data = [");
        for(int i = maxn-1; i >= 0; --i){
            ksprintf(s, "trace%d,", i);
        }
        ksprintf(s, "trace%d,", maxn);
        ksprintf(s, "];\n");
        ksprintf(s, "var layout = {\n");
        ksprintf(s, "  title: 'Edit Product Frequency From Top%d Shared Indels Across %lu Samples',\n", topn, grns.empty() ? samples.size() : samples.size()-grns.size()+1);
        ksprintf(s, "  hovermode: 'closest',\n");
        ksprintf(s, "  barmode: 'stack',\n");
        ksprintf(s, "  height: %d,\n", MAX(800, MIN(800, maxn * 20)));
        ksprintf(s, "  width: %d,\n", hw);
        ksprintf(s, "  xaxis:{\n");
        ksprintf(s, "    automargin: true,\n");
        ksprintf(s, "    type: 'multicategory',\n");
        ksprintf(s, "    dtick: 1,\n");
        ksprintf(s, "    tickson: 'boundaries',\n");
        ksprintf(s, "    ticklen: 15,\n");
        ksprintf(s, "    showdividers: true,\n");
        ksprintf(s, "    dividercolor: 'grey',\n");
        ksprintf(s, "    dividerwidth: 2,\n");
        ksprintf(s, "    title: {\n");
        ksprintf(s, "      text: 'samples and genotypes',\n");
        ksprintf(s, "      standoff: 20,\n");
        ksprintf(s, "    },\n");
        ksprintf(s, "  },\n");
        ksprintf(s, "  yaxis:{\n");
        ksprintf(s, "    automargin: true,\n");
        ksprintf(s, "    title: {\n");
        ksprintf(s, "      text: 'edit product frequency',\n");
        ksprintf(s, "      standoff: 20,\n");
        ksprintf(s, "    },\n");
        ksprintf(s, "  },\n");
        ksprintf(s, "};\n");
        ksprintf(s, "var config = {\n");
        ksprintf(s, "  toImageButtonOptions: {\n");
        ksprintf(s, "    format: 'svg',\n");
        ksprintf(s, "     filename: 'topn.shared.group.by.genotype',\n");
        ksprintf(s, "     height: %d,\n", MAX(800, MIN(800, maxn * 20)));
        ksprintf(s, "     width: %d,\n", hw);
        ksprintf(s, "     scale: 1,\n");
        ksprintf(s, "  }\n");
        ksprintf(s, "};\n");
        ksprintf(s, "Plotly.newPlot(plot_gcalgid, data, layout, config)\n");
        ksprintf(s, "</script>\n");
        ksprintf(s, "</div>\n");
        if(p4g->s){ free(p4g->s); free(p4g); }
    }
    // Plot group by genotype end
    // DR plot beg
    if(drmethod > 0 && drmethod <= DR_METHOD_CNT){
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('gdrid')><a name='gdrid'>%s plot of samples by top%d allele frequency</a></div>\n", DR_METHOD2STR_ARR[drmethod],  topn);
    ksprintf(s, "<div id='gdrid'>\n");
    ksprintf(s, "<div id='plot_gdrid' class='figure' width='800' height='800'></div>\n");
    ksprintf(s, "</div>\n");
    ksprintf(s, "\n<script type=\"text/javascript\">\n");
    ksprintf(s, "let indata = [");
    for(int i = 0; i < nsamples; ++i){
        if(sgrps.find(samples[i]) != sgrps.end()) continue;
        ksprintf(s, "[");
        for(int j = 0; j < nallele; ++j) ksprintf(s, "%lf,", pa4s[i][j]);
        ksprintf(s, "],");
    }
    s->s[s->l-1] = ']';
    ksprintf(s, ";\n");
    ksprintf(s, "let mat = druid.Matrix.from(indata);\n");
    if(drmethod == DR_METHOD_UMAP){
        ksprintf(s, "let drm = new druid.UMAP(mat, {n_neighbors: %d, local_connectivity: 1, d: 2, min_dist: 2, });\n", nsamples < 15 ? nsamples : 15);
    }else if(drmethod == DR_METHOD_PCA){
        ksprintf(s, "let drm = new druid.PCA(mat, {d: 2,});\n");
    }
    ksprintf(s, "drm.transform();\n");
    ksprintf(s, "let tarray = drm.Y.asArray;\n");
    ksprintf(s, "let grps = [");
    std::unordered_map<std::string, std::string> i2nm;
    if(sid2grp.empty() && gttype.empty()){
        for(int i = 0; i < nsamples; ++i){
            if(sgrps.find(samples[i]) != sgrps.end()) continue;
            ksprintf(s, "'Default',");
        }
        uniqs.push_back("Default");
        i2nm["Default"] = "Default";
    }else if(sid2grp.size()){
        std::unordered_set<std::string> uqss;
        for(size_t i = 0; i < sid2grp.size(); ++i){
            i2nm[sidngrp[i]] = sid2grp[i];
            if(sgrps.find(samples[i]) != sgrps.end()) continue;
            ksprintf(s, "'%s',", sidngrp[i].c_str());
            if(uqss.find(sidngrp[i]) == uqss.end()){
                uqss.insert(sidngrp[i]);
                uniqs.push_back(sidngrp[i]);
            }
        }
    }else if(gttype.size()){
        std::unordered_set<std::string> uqss;
        for(int i = 0; i < GT_TYPE_CNT; ++i) i2nm[GT_INT2VAR_ARR[i]] = GT_INT2STR_ARR[i];
        for(int i = 0; i < nsamples; ++i){
            ksprintf(s, "'%s',", GT_INT2VAR_ARR[gttype[i]]);
            if(uqss.find(GT_INT2VAR_ARR[gttype[i]]) == uqss.end()){
                uqss.insert(GT_INT2VAR_ARR[gttype[i]]);
                uniqs.push_back(GT_INT2VAR_ARR[gttype[i]]);
            }
        }
    }
    s->s[s->l-1] = ']';
    ksprintf(s, ";\n");
    ksprintf(s, "let spns = [");
    for(int i = 0; i < nsamples; ++i){
        if(sgrps.find(samples[i]) != sgrps.end()) continue;
        ksprintf(s, "'%s',", samples[i].c_str());
    }
    s->s[s->l-1] = ']';
    ksprintf(s, ";\n");
    for(auto& e: uniqs){
        ksprintf(s, "xarr%s = [];\n", e.c_str());
        ksprintf(s, "yarr%s = [];\n", e.c_str());
        ksprintf(s, "tarr%s = [];\n", e.c_str());
    }
    ksprintf(s, "for(var i = 0; i < tarray.length; i++){\n");
    ksprintf(s, "    let xy = tarray[i];\n");
    for(auto& e: uniqs){
        ksprintf(s, "    if(grps[i] == '%s'){\n", e.c_str());
        ksprintf(s, "        xarr%s.push(xy[0]);\n", e.c_str());
        ksprintf(s, "        yarr%s.push(xy[1]);\n", e.c_str());
        ksprintf(s, "        tarr%s.push(spns[i]);\n", e.c_str());
        ksprintf(s, "        continue;\n");
        ksprintf(s, "    }\n");
    };
    ksprintf(s, "}\n");
    for(auto& e: uniqs){
        ksprintf(s, "var trace%s = {\n", e.c_str());
        ksprintf(s, "    x: xarr%s,\n", e.c_str());
        ksprintf(s, "    y: yarr%s,\n", e.c_str());
        ksprintf(s, "    name: '%s',\n", i2nm[e.c_str()].c_str());
        ksprintf(s, "    type: 'scatter',\n");
        if(showt){
            ksprintf(s, "    mode: 'markers+text',\n");
            ksprintf(s, "    text: tarr%s,\n", e.c_str());
            ksprintf(s, "    textposition: 'bottom',\n");
        }else{
            ksprintf(s, "    mode: 'markers',\n");
            ksprintf(s, "    hovertext: tarr%s,\n", e.c_str());
        }
        ksprintf(s, "};\n");
    }
    ksprintf(s, "var data = [");
    for(auto& e: uniqs){
        ksprintf(s, "trace%s,", e.c_str());
    }
    s->s[s->l-1] = ']';
    ksprintf(s, ";\n");
    ksprintf(s, "var layout = {\n");
    ksprintf(s, " title: '%s plot of samples by top%d allele frequency',\n", DR_METHOD2STR_ARR[drmethod], topn);
    ksprintf(s, " showlegend: true,\n");
    ksprintf(s, " xaxis:{\n");
    ksprintf(s, "  automargin: true,\n");
    ksprintf(s, "  title:{\n");
    ksprintf(s, "    text: '%s1',", DR_METHOD2AXIS_ARR[drmethod]);
    ksprintf(s, "  },\n");
    ksprintf(s, " },\n");
    ksprintf(s, " yaxis:{\n");
    ksprintf(s, "  automargin: true,\n");
    ksprintf(s, "  title:{\n");
    ksprintf(s, "    text: '%s2',", DR_METHOD2AXIS_ARR[drmethod]);
    ksprintf(s, "  },\n");
    ksprintf(s, " },\n");
    ksprintf(s, "};\n");

    ksprintf(s, "var config ={\n");
    ksprintf(s, "  toImageButtonOptions: {\n");
    ksprintf(s, "    format: 'svg',\n");
    ksprintf(s, "    filename: 'sp.alle.freq.%s.svg',\n", DR_METHOD2STR_ARR[drmethod]);
    ksprintf(s, "    height: 800,\n");
    ksprintf(s, "    width: 800,\n");
    ksprintf(s, "    scale: 1,\n");
    ksprintf(s, "  }\n");
    ksprintf(s, "};\n");

    ksprintf(s, "Plotly.newPlot('plot_gdrid', data, layout, config);\n");
    ksprintf(s, "</script>\n");
    }
    // DR plot end
    // TopN table beg
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('gtopnvs')><a name='gtopnvs'>Top%d shared edit products</a></div>\n", topn);
    ksprintf(s, "<div id='gtopnvs'>\n");
    ksprintf(s, "<table class='summary_table' id='gtopnvs_table'>\n");
    {
        // head
        ksprintf(s, "<thead>\n");
        ksprintf(s, "<tr>");
        ksprintf(s, "<th class='col2'>Amplicon</th>");
        ksprintf(s, "<th class='col2'>Start</th>");
        ksprintf(s, "<th class='col2'>End</th>");
        ksprintf(s, "<th class='col2'>Type</th>");
        ksprintf(s, "<th class='col2'>Ref</th>");
        ksprintf(s, "<th class='col2'>Alt</th>");
        ksprintf(s, "<th class='col2'>Frameshift</th>");
        ksprintf(s, "<th class='col2'>SharedCNT</th>");
        for(size_t i = 0; i < samples.size(); ++i){
            if(sgrps.find(samples[i]) == sgrps.end()){
                ksprintf(s, "<th class='col2'>%s</th>", samples[i].c_str());
            }
        }
        ksprintf(s, "</tr>");
        ksprintf(s, "</thead>\n");
        // body
        ksprintf(s, "<tbody>\n");
        ksprintf(s, "%s", tst->s);
        ksprintf(s, "</tbody>\n");
        ksprintf(s, "</table>\n");
        hmo.printExportButtons(s, "gtopnvs_table", "topn.share.vars");
        free(tst->s);
        free(tst);
    }
    ksprintf(s, "</div>\n");
    ksprintf(s, "</div>\n");
    // TopN table end
    size_t maacn = gtnacc[0].size();
    for(size_t i = 1; i < gtnacc.size(); ++i){
        if(gtnacc[i].size() > maacn) maacn = gtnacc[i].size();
    }
    if(maacn > (size_t)topn) maacn = topn;
    // Allele freq acc beg
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('gtaccfs')><a name='gtaccfs'>Accumulated edited allele frequency</a></div>\n");
    ksprintf(s, "<div id='gtaccfs'>\n");
    ksprintf(s, "<table class='summary_table' id='gtaccfs_table'>\n");
    {
        // head
        ksprintf(s, "<thead>\n");
        ksprintf(s, "<tr><th class='col1'>Sample</th>");
        ksprintf(s, "<th class='col2'>QualifiedSeqs</th>");
        ksprintf(s, "<th class='col2'>EditedRate</th>");
        if(calg) ksprintf(s, "<th class='col2'>Genotype</th>");
        for(size_t i = 1; i <= maacn; ++i){
            ksprintf(s, "<th class='col2'>Top%ld</th>", i);
        }
        ksprintf(s, "</tr></thead>\n");
        // body
        ksprintf(s, "<tbody>\n");
        for(size_t u = 0 ; u < samples.size(); ++u){
            if(sgrps.find(samples[u]) != sgrps.end()) continue;
            ksprintf(s, "<tr>");
            ksprintf(s, "<td class='col2'>%s</td>", samples[u].c_str());
            ksprintf(s, "<td class='col2'>%lld</td>", totcnt[u]);
            ksprintf(s, "<td class='col2'>%lf</td>", edieff[u]);
            if(calg) ksprintf(s, "<td class='col2'>%s</td>", GT_INT2STR_ARR[gttype[u]]);
            for(size_t i = 0; i < gtnacc[u].size(); ++i){
                ksprintf(s, "<td class='col2'>%lf</td>", gtnacc[u][i]);
            }
            for(size_t i = gtnacc[u].size(); i < maacn; ++i){
                ksprintf(s, "<td class='col2'> </td>");
            }
            ksprintf(s, "</tr>");
        }
        ksprintf(s, "</tbody></table>\n");
        hmo.printExportButtons(s, "gtaccfs_table", "allele.freq.acc");
    }
    ksprintf(s, "</div>\n");
    ksprintf(s, "</div>\n");
    // Allele freq acc end
}

void gtn_opt_t::html2foot(kstring_t* s){
    hmo.html2foot(s);
}

int gtn_opt_t::call_gt(std::vector<variant_t *> &vs, double ef){
    int gt = GT_HOMO_WTWT_TYPE;
    if(vs.empty()) return gt;;
    variant_t* wv = new variant_t();
    wv->ref = ".";
    wv->alt = ".";
    wv->freq = 1-ef;
    wv->ntype = GEVAR_REF;
    wv->type = GEV_STR_ARR[GEVAR_REF];
    vs.push_back(wv);
    std::sort(vs.begin(), vs.end(), VarSortByFreq());
    double mf = .0;
    bool winp2 = false;
    for(int i = 0; i < 2; ++i){
        if(vs[i]->ntype & type) mf += vs[i]->freq;
        if(vs[i]->ntype == GEVAR_REF) winp2 = true;
    }
    if(mf < 0.2){
        if(winp2 &&  wv->freq > mrv){
            gt = GT_HOMO_WTWT_TYPE;
        }else{
            gt = GT_MIX_MTLOWFREQ_TYPE;
        }
    }else if(mf >= 0.2 && mf < 0.8){
        if(winp2 && wv->freq > mxv){
            gt = GT_HETERO_WTMT_TYPE;
        }else{
            gt = GT_MIX_MTHIGHFREQ_TYPE;
        }
    }else{
        if(vs[1]->freq > 0.2){
            gt = GT_HETERO_MTMT2_TYPE;
        }else{
            gt = GT_HOMO_MTMT_TYPE;
        }
    }
    delete wv;
    return gt;
}
