#ifndef OPTIONS_H
#define OPTIONS_H

#include <cstdio>
#include <cassert>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <fstream>
#include <string>
#include <vector>
#include <mutex>
#include <map>
#include "ksw4get.h"
#include "util.h"
#include "prefix.h"
#include "preidx.h"
#include "ampidx.h"
#include "common.h"
#include "htmlopt.h"
#include "software.h"
#include "amplicon.h"
#include "threadpool.h"
#include "htslib/vcf.h"
#include "htslib/sam.h"


// low quality threshold
struct LowQualOpt{
    int minBaseQual = 20; // min base quality to be considered as low qual base
    int maxLowQualBase = 40; // max low quality base count allowed for an high qual read
    float maxLowQualFrac = 0.15; // max low qualiy base frac allowed for an high qual read
    int maxN = 5; // max N allowed for an high qual read
};

// merge pe options
struct MergePEOpt{
    bool allowMergeStagger = true; // allow merge reads with adapters
    int maxdiffs = 10; // max number of different bases in merge regions
    float maxdiffpct = 100; // max number of different base percent in merge regions
    int minovlen = 10; // min number of overlap length between reads
};

// alignment options
struct AlignOpt{
    int match = 5;
    int mismatch = 4;
    int gapopen = 25;
    int gapext = 0;
};

// edit options
struct EditOpt{
    float minaf = 0.0;
    int minseqc = 1;
    int maxvc = 0xFFFF;
    int cutbuflen = 5;
    int clsbpos = -1;
    int clsepos = -1;
    int vartypem = GEVAR_DEL|GEVAR_INS;
    int rectypem = REC_ANYHIT_IS_EDIT;
    bool greedy = false;
    int minextram = 30;
    bool cluster = false;
    bool plotge = true;
    int flklen = 25;
    int topn = 50;
    int mpmatch = 30;
    bool ismt = false;
    int ctfc = 3; // control filter threshold
    int minqs1k = 1000; // min qualified sequence count1
    int minqs10k = 10000; // min qualified sequence count2
    bool hapcnt = false; // hapcnt sgrnapam region
};

// options
struct Options{
    // io
    std::string in1; // read1 input file
    std::string in2; // read2 input file
    std::string ctrl; // control BAM generated by getools
    std::string prf; // prefix configure file
    std::string outdir; // output directory
    std::string pltdir; // output detail dir
    bool tpdetail; // output tsv and pdf details
    std::string htmldir; // htmls directory
    std::string hapdir; // hapsubdir
    std::string tmpdir; // temporary directory
    std::string droplib; // drop library name
    uint8_t f4bout; // flag for bamout
    bool dosccal; // do single cell computation
    int dropidx; // drop library index
    std::string hmr; // out put html report
    std::string jsr; // split result json report file
    std::string tsr; // split result tsv report file 
    std::string tsm; // split result tsv report file(all amplicon split results merged into one cell)
    std::string jss; // sub lib json report file
    std::string tss; // sub lib tsv report file
    std::string txx_se, txx_pe; // fq2bam ref xx tsv report
    bool memlow; // low memory mode
    int memone; // # of samples one time in mem
    bool outspl; // output split fastq if true
    bool outgz; // output gz file if true
    bool s8aln; // split by alignment against all amplicon sequences
    int compression; // compression level
    int thread; // number of threads used to do do split/write
    int maxpack; // max packs used to store reads
    int maxreads; // max reads in one pack
    // split
    size_t skipfr1; // skip length for extra seq(adapter, index,.etc) in read1 5'end
    size_t skipfr2; // skip length for extra seq(adapter, index,.etc) in read2 5'end
    int maxmm; // max mismatch allowed
    int maxoff; // max offset allowed before match
    int maxbo; // max barcode sequence length to skip during checking primers
    size_t maxpl; //  max prefix length
    int maxml; // max match length to look for prefix
    size_t minlen; // min read length allowed
    bool useHash; // use hash match if possible
    bool droppre; // drop matched prefix if true
    bool sematch; // single end match is okay
    bool usesem; // use single matched to do analysis
    bool isq64; // ASCII base of base quality is 64
    bool adjfr; // adjust output read1/2 as forward/reverse matched by prefix/primer
    bool ostrand; // output strand of read1/2 as +/- matched by prefix/primer
    bool recstat; // recombination insertion added to stat
    bool dmatch; // duplicated single index there, do dmatch
    std::set<size_t> vblens; // variout prefix length
    pre_idx_t* preidx; // pref index for primer alignment based split
    amp_idx_t* ampidx; // amplicon index for amplicon alignment based split
    // work marker
    bool fq2spl; // split fastq to fastqs
    bool fq2bam; // split fastq to BAM
    bool fq2cal; // fastq to caledit
    // other
    Software* soft; // software environment
    PrefixList prl; // prefix list(fw,rev; rev,fw pairs)
    PrefixList prs; // prefix list(only fw,rev pairs)
    PrefixHash prh; // prefix hash hash
    PreStrHash psh; // prefix str hash
    std::string hrjsn; // html json configure file
    std::vector<std::string> samples; // sub samples
    AmpliconList amplicons; // amplicons
    ThreadPool* tpl; // thread pool
    LowQualOpt lowq; // low qual threshold
    MergePEOpt mpe; // merge pe options
    AlignOpt aln;   // align options
    EditOpt edo; // edit options
    HtmlOpt hmo; // html options
    std::mutex logmtx; // log mutex
    bcf_hdr_t* bcfh; // bcf hdr
    bam_hdr_t* bamh; // bam hdr
    std::string extsnv; // extra snv to focus

    // constructor
    Options();

    // destructor
    ~Options();

    // update
    void update(int argc, char** argv);

    // parsing prefix configure file for fast access
    // configure file is a three column tsv file without header
    // field1: sample name
    // field2: forward primer
    // field3: reverse primer
    // field4: amplicon sequence (caledit, fq2bam needed)
    // field5: sgRNA+PAM squence (caledit needed)
    // field6: donor sequence (caledit HDR needed)
    bool parsePreCfg();
    bool parseSplCfg();
    bool parseFq2bamCfg();
    bool donor2amp(amplicon_t* amp);
    
    // parse hash of prefix
    void genHash();

    // initialize
    void init(int argc, char** argv);

    // validate
    bool valid();

    // update dmatch
    void setdm();

    // cleanup
    void cleanup();

    bool checkps(const std::string& pfwd, const std::string& prev, const std::string& amps, int& bfo, int &bro);
};

#endif
