#ifndef GET_SCANA_H
#define GET_SCANA_H

#include "gtn.h"
#include <string>
#include <unordered_set>

struct sc_var_t{
    std::string ref = "REF";
    std::string alt = "ALT";
    int32_t start = 0;
    int32_t end = 0;
    double bfreq = .0; // batch freq
    int32_t bcnt = 0; // batch depth
    int width = 0; // width
    std::string type = "Others"; // type
    std::unordered_map<std::string, int32_t> scnt; // single cell cnt
};

// variant sorter
struct ScVarSortByFreq{
    bool operator()(const sc_var_t* v1, const sc_var_t* v2) const {
        return v1->bfreq > v2->bfreq;
    }
};

struct amp_cnt_t{
    int rawcnt = 0;
    int totcnt = 0;
    double edieff = .0;
    double muteff = .0;
    double recpef = .0;
    double receff = .0;
    double reeeff = .0;
    bool isval = false;
    bool ison = false;
};

struct sc_trec_t{
    int a = 0;
    bool onedited = false;
    bool v = false;
};

struct sc_cnt_t{
    int d = 0;
    int e = 0;
    int r = 0;
    int o = 0;
    int a = 0;
    double ge = .0;
    double go = .0;
    bool v = false;
};

typedef std::unordered_map<std::string, sc_cnt_t*> SingleCellEditStatCountMap;
typedef std::unordered_map<std::string, sc_trec_t*> SingleCellWholeStatCountMap;

// opts
struct scana_opt_t{
    std::string inbcf; // input var.bcf generated by getools caledit -K
    std::string otgl; // on target amplicon list
    std::string outdir = "./"; // output directory
    std::string ampalle4sctsv = SCANA_AMP_ALLELE_IN_SC_TSV; // amplicon allele in sc
    std::string ampcoedittsv = SCANA_AMP_CO_EDIT_TSV; // amplicon co-edit status
    std::string ampediteff4sc = SCANA_AMP_SC_EDIT_EFF; // amplicon edit rate for single cell
    std::string otgedit4sc = SCANA_OTG_EDIT_SC; // on-target edited status for valid cells
    std::string cellfindtsv = SCANA_CELL_FIND_JSON; // cell finder compute process
    std::string sc2html = SCANA_HTML_RESULT; // html report file
    std::unordered_set<std::string> otgs; // on target amplicon names
    double minf4meanr = .2; // min of mean reads to use as threshold
    int minavgd4amp = 8; // min mean depth for amplicons
    double minf4vcell = .8; // min fraction of amplicons must exceed threshold in one cell
    int topn = 50; // topN batch events to do single cell analysis
    int type = 6;
    int nctc = 3;
    double minscedf = .3;
    double minscotf = .3;
    kstring_t* pa2s = NULL;
    kstring_t* ps2a = NULL;
    kstring_t* pe2a = NULL;
    kstring_t* poes = NULL;
    kstring_t* ptmp = NULL;
    std::vector<SingleCellEditStatCountMap> scsc;
    std::vector<amp_cnt_t*> ampcnts;
    SingleCellWholeStatCountMap scwm;
    // stat items
    int32_t rawc = 0;
    int32_t rawa = 0;
    int th4minavdep = 0;
    int32_t cafth4minavdep = 0;
    int32_t th4mom = 0;
    int32_t aafth4mon = 0;
    int32_t cafth4mon = 0;
    int32_t th4amp = 0;
    int32_t caffrac = 0;
    HtmlOpt hmo;
    std::string hrjsn;
    // UMAP
    double **pedim = NULL;
    int *nedim = NULL;
    int mn4t = 0;

    scana_opt_t();
    ~scana_opt_t();

    bool valid();
    void init();
    void a2sh();
    void umap();
    void findc();
    void cs2jsn();
    void cs2html();
    void html2head(kstring_t* s);
    void html2body(kstring_t* s);
    void html2foot(kstring_t* s);
    void ana4all();
    void amp4one(bcf_hdr_t* hdr, int i);
    void ana4one(htsFile* fp, hts_idx_t* idx, bcf_hdr_t* hdr, int i);
};

void scana_usage(scana_opt_t* opt, char* arg0);

int scana_main(int argc, char** argv);

#endif
