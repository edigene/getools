#include "scana.h"

scana_opt_t::scana_opt_t(){
}

scana_opt_t::~scana_opt_t(){
    if(pa2s){
        if(pa2s->s){ free(pa2s->s); pa2s->s = NULL; }
        free(pa2s);
        pa2s = NULL;
    }
    if(ps2a){
        if(ps2a->s){ free(ps2a->s); ps2a->s = NULL; }
        free(ps2a);
        ps2a = NULL;
    }
    if(pe2a){
        if(pe2a->s){ free(pe2a->s); pe2a->s = NULL; }
        free(pe2a);
        pe2a = NULL;
    }
    if(poes){
        if(poes->s){ free(poes->s); poes->s = NULL; }
        free(poes);
        poes = NULL;
    }
    if(ptmp){
        if(ptmp->s){ free(ptmp->s); ptmp->s = NULL; }
        free(ptmp);
        ptmp = NULL;
    }
    for(auto& e: scsc){
        for(auto& p: e){
            if(p.second){
                free(p.second);
                p.second = NULL;
            }
        }
        e.clear();
    }
    scsc.clear();
    for(auto& e: ampcnts){
        if(e){ free(e); e = NULL;}
    }
    ampcnts.clear();
    for(auto& e: scwm){
        if(e.second){
            free(e.second);
            e.second = NULL;
        }
    }
    if(pedim){
        for(int i = 0; i < caffrac; ++i) free(pedim[i]);
        free(pedim);
        pedim = NULL;
    }
    if(nedim){
        free(nedim);
        nedim = NULL;
    }
    scwm.clear();
}

bool scana_opt_t::valid(){
    if(inbcf.empty() || (!util::exists(inbcf))){
        fprintf(stderr, "input var.bcf generated by getools must be provided!\n");
        return false;
    }

    if(topn < 1){
        fprintf(stderr, "at least one var needed to do single cell variants analysis!\n");
        return false;
    }
    return true;
}

void scana_opt_t::init(){
    if(!util::exists(outdir)) util::makedir(outdir);
    ampalle4sctsv = util::joinpath(outdir, ampalle4sctsv);
    ampcoedittsv = util::joinpath(outdir, ampcoedittsv);
    ampediteff4sc = util::joinpath(outdir, ampediteff4sc);
    otgedit4sc = util::joinpath(outdir, otgedit4sc);
    cellfindtsv = util::joinpath(outdir, cellfindtsv);
    sc2html = util::joinpath(outdir, sc2html);
    pa2s = (kstring_t*)calloc(1, sizeof(kstring_t));
    ps2a = (kstring_t*)calloc(1, sizeof(kstring_t));
    pe2a = (kstring_t*)calloc(1, sizeof(kstring_t));
    poes = (kstring_t*)calloc(1, sizeof(kstring_t));
    ptmp = (kstring_t*)calloc(1, sizeof(kstring_t));
    if(otgl.size() && util::exists(otgl)) util::makeSetFromFileByLine(otgl, otgs);
    hmo.init(hrjsn);
    a2sh();
}

void scana_opt_t::umap(){
    pedim = (double**)malloc(caffrac * sizeof(double*));
    nedim = (int*)calloc(caffrac, sizeof(int));
    for(int i = 0; i < caffrac; ++i){
        pedim[i] = (double*)calloc(rawa, sizeof(double));
    }
    int n4t = 0, i = 0;
    mn4t = 0;
    for(auto& s: scwm){
        if(!s.second->v) continue;
        n4t = 0;
        for(int j = 0; j < rawa; ++j){
            auto iter = scsc[j].find(s.first);
            if(iter != scsc[j].end()){
                if(iter->second->v){
                    if(iter->second->ge > minscedf){
                        pedim[i][j] = iter->second->ge;
                        if(ampcnts[j]->ison) ++n4t;
                    }
                }else{
                    pedim[i][j] = .0;
                }
            }else{
                pedim[i][j] = .0;
            }
        }
        if(n4t > mn4t) mn4t = n4t;
        nedim[i] = n4t;
        ++i;
    }
}

void scana_opt_t::a2sh(){
    ksprintf(pa2s, "Amplicon\tREF\tALT\tF\tbatchFreq\tbatchCount\tscNumber\tscFreq\n");
}

void scana_opt_t::findc(){
    // at least average minavgd4amp[8] depth of each amplicon in all cells
    th4minavdep = ampcnts.size() * minavgd4amp;
    rawa = ampcnts.size();
    rawc = scwm.size();
    cafth4minavdep = 0;
    for(auto& p: scwm){
        if(p.second->a < th4minavdep) p.second->v = false;
        else{
            p.second->v = true;
            ++cafth4minavdep;
        }
    }
    for(auto& e: scsc){
        for(auto& p: e){
            if(scwm[p.first]->v){
                p.second->v = true;
            }else{
                p.second->v = false;
            }
        }
    }
    // calculate minf4meanr[.2] * (mean depth of means of each amplicon depth) as depth threshold
    th4mom = 0;
    std::vector<int32_t> m4amps(scsc.size(), 0);
    for(size_t i = 0; i < scsc.size(); ++i){
        int64_t t = 0;
        for(auto& p: scsc[i]){
            if(p.second->v) t += p.second->a;
        }
        if(scsc[i].empty()) m4amps[i] = 0;
        else m4amps[i] = (double)t/(double)cafth4minavdep;
        th4mom += m4amps[i];
    }
    th4mom = (double)th4mom/double(m4amps.size()) * minf4meanr;
    aafth4mon = cafth4mon = 0;
    // filter amplicons by th4mom and recal scwm
    for(size_t i = 0; i < m4amps.size(); ++i){
        if(m4amps[i] > th4mom){
            ampcnts[i]->isval = true;
            ++aafth4mon;
        }else{
            ampcnts[i]->isval = false;
            for(auto& e: scsc[i]) scwm[e.first]->a -= e.second->a;
        }
    }
    // filter cells by th4mom
    for(auto& p: scwm){
        if(p.second->a < th4mom) p.second->v = false;
    }
    for(auto& p: scwm){
        if(p.second->v) ++cafth4mon;
    }
    for(auto& e: scsc){
        for(auto& p: e){
            if(!scwm[p.first]->v){
                p.second->v = false;
            }
        }
    }
    // filter cells by minf4vcell[0.8] amplicons in each cell has depth > th4mom
    th4amp = minf4vcell * aafth4mon;
    for(auto& p: scwm){
        if(p.second->v){
            int x8p = 0;
            for(auto& e: scsc){
                auto iter = e.find(p.first);
                if(iter != e.end() && iter->second->v && iter->second->a > th4mom) ++x8p;
            }
            if(x8p < th4amp) p.second->v = false;
        }
    }
    for(auto& e: scsc){
        for(auto& p: e){
            if(!scwm[p.first]->v){
                p.second->v = false;
            }
        }
    }
    for(auto& p: scwm){
        if(p.second->v) ++caffrac;
    }
}

void scana_opt_t::cs2jsn(){
    ptmp->l = 0;
    ksprintf(ptmp, "{\n");
    ksprintf(ptmp, " \"RawCells\": %d,\n", rawc);
    ksprintf(ptmp, " \"RawAmplicons\": %d,\n", rawa);
    ksprintf(ptmp, " \"MinDepthThreshold4Cell\": %d,\n", th4minavdep); 
    ksprintf(ptmp, " \"CellsPassMinDepth\": %d,\n", cafth4minavdep);
    ksprintf(ptmp, " \"MeanDepthThreshold\": %d,\n", th4mom);
    ksprintf(ptmp, " \"AmpliconsPassMeanDepthThreshold\": %d,\n", aafth4mon);
    ksprintf(ptmp, " \"CellsPassMeanDepth\": %d,\n", cafth4mon);
    ksprintf(ptmp, " \"NumberOfCellsNeedeedToPassMeanDepthThreshold\": %d,\n", th4amp);
    ksprintf(ptmp, " \"CellsWithEnoughAmpliconsPassMeanDepthThreshold\": %d\n", caffrac);
    ksprintf(ptmp, "}\n");
    FILE* fp = fopen(cellfindtsv.c_str(), "w");
    fwrite(ptmp->s, sizeof(char), ptmp->l, fp);
    fclose(fp);
}

void scana_opt_t::cs2html(){
    ptmp->l = 0;
    html2head(ptmp);
    html2body(ptmp);
    html2foot(ptmp);
    FILE* fp = fopen(sc2html.c_str(), "w");
    fwrite(ptmp->s, sizeof(char), ptmp->l, fp);
    fclose(fp);
}

void scana_opt_t::html2head(kstring_t* s){
    hmo.html2head(s, "scana");
}

void scana_opt_t::html2body(kstring_t* s){
    // Summary beg
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('summary')><a name='summary'>Summary</a></div>\n");
    ksprintf(s, "<div id='summary'>\n");
    // Summary -> Samples beg
    ksprintf(s, "<div class='subsection_title' onclick=showOrHide('general')>Summary</div>\n");
    ksprintf(s, "<div id='smps'>\n");
    ksprintf(s, "<table class='summary_table'>\n");
    {
        // raw cells
        ksprintf(s, "<tr>");
        ksprintf(s, "<td class='col1'>Raw cells</td>");
        ksprintf(s, "<td class='col2'>%d</td>", rawc);
        ksprintf(s, "</tr>");
        // valid cells
        ksprintf(s, "<tr>");
        ksprintf(s, "<td class='col1'>Valid cells</td>");
        ksprintf(s, "<td class='col2'>%d</td>", caffrac);
        ksprintf(s, "</tr>");
        // raw amplicons
        ksprintf(s, "<tr>");
        ksprintf(s, "<td class='col1'>Amplicons in panel</td>");
        ksprintf(s, "<td class='col2'>%d</td>", rawa);
        ksprintf(s, "</tr>");
        // amplicons passed depth 
        ksprintf(s, "<tr>");
        ksprintf(s, "<td class='col1'>QC passed amplicons</td>");
        ksprintf(s, "<td class='col2'>%d</td>", aafth4mon);
        ksprintf(s, "</tr>");
    }
    ksprintf(s, "</table>\n");
    ksprintf(s, "</div>\n");
    // Summary -> Samples end
    ksprintf(s, "</div>\n");
    ksprintf(s, "</div>\n");
    // Summary end
    // Download link beg
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('scresult')><a name='scresult'>Single Cell Analysis Results</a></div>\n");
    ksprintf(s, "<div id='scresult'>\n");
    ksprintf(s, "<table class='summary_table' id='scresult_table'>\n");
    {
        // thead
        ksprintf(s, "<thead>\n");
        ksprintf(s, "<tr><th class='col1'>Link2ResultTable</th>");
        ksprintf(s, "<th class='col2'>Content</th>");
        ksprintf(s, "</thead>\n");
        // tbody
        ksprintf(s, "<tbody>\n");
        ksprintf(s, "<tr><td class='col2'><a href='./%s'>Allele table</a></td>", SCANA_AMP_ALLELE_IN_SC_TSV);
        ksprintf(s, "<td class='col2'>Top%d allele of amplicons in valid cells</td></tr>", topn);
        ksprintf(s, "<tr><td class='col2'><a href='./%s'>Co-edit table</a></td>", SCANA_AMP_CO_EDIT_TSV);
        ksprintf(s, "<td class='col2'>Amplicons overall edit status all valid cells</td></tr>");
        ksprintf(s, "<tr><td class='col1'><a href='./%s'>Cell finder process</a></td>", SCANA_CELL_FIND_JSON);
        ksprintf(s, "<td class='col2'>Valid cell computation procedure</td></tr>");
        ksprintf(s, "</table>\n");
    }
    ksprintf(s, "</div>\n");
    ksprintf(s, "</div>\n");
    // Download link end
    // UMAP beg
    ksprintf(s, "<div class='section_div'>\n");
    ksprintf(s, "<div class='section_title' onclick=showOrHide('plot_scumap')><a name='scresult'>Single Cell UMAP analysis</a></div>\n");
    ksprintf(s, "<div class='figure' id='plot_scumap'></div></div>\n");
    ksprintf(s, "\n<script type=\"text/javascript\">\n");
    ksprintf(s, "let grps = [");
    for(int i = 0; i < caffrac; ++i){
        ksprintf(s, "%d,", nedim[i]);
    }
    s->s[s->l-1] = ']';
    ksprintf(s, ";\n");
    ksprintf(s, "let indata = [");
    for(int i = 0; i < caffrac; ++i){
        ksprintf(s, "[");
        for(int j = 0; j < rawa; ++j){
            ksprintf(s, "%f,", pedim[i][j]);
        }
        s->s[s->l-1] = ']';
        ksprintf(s, ",\n");
    }
    s->s[s->l-1] = ']';
    ksprintf(s, ";\n");
    ksprintf(s, "let mat = druid.Matrix.from(indata);\n");
    ksprintf(s, "let umap = new druid.UMAP(mat, {n_neighbors: %d, local_connectivity: 1, d: 2, min_dist: 2,});\n", caffrac < 15 ? caffrac : 15);
    ksprintf(s, "umap.transform();\n");
    ksprintf(s, "let tarray = umap.Y.asArray;\n");
    for(int i = 0; i <= mn4t; ++i){
        ksprintf(s, "xarr%d = [];\n", i);
        ksprintf(s, "yarr%d = [];\n", i);
    }
    ksprintf(s, "for(var i = 0; i < tarray.length; i++){\n");
    ksprintf(s, "    let xy = tarray[i];\n");
    ksprintf(s, "    if(grps[i] == 0){\n");
    ksprintf(s, "        xarr0.push(xy[0]);\n");
    ksprintf(s, "        yarr0.push(xy[1]);\n");
    for(int i = 1; i <= mn4t; ++i){
        ksprintf(s, "    }else if(grps[i] == %d){\n", i);
        ksprintf(s, "        xarr%d.push(xy[0]);\n", i);
        ksprintf(s, "        yarr%d.push(xy[1]);\n", i);
    }
    ksprintf(s, "  }\n");
    ksprintf(s, "}\n");
    for(int i = 0; i <= mn4t; ++i){
        ksprintf(s, "var trace%d = {\n", i);
        ksprintf(s, "    x: xarr%d,\n", i);
        ksprintf(s, "    y: yarr%d,\n", i);
        ksprintf(s, "    name: '%dEdtiedTargets',\n", i);
        ksprintf(s, "    type: 'scatter',\n");
        ksprintf(s, "    mode: 'markers',\n");
        ksprintf(s, "};\n");
    }
    ksprintf(s, "var data = [");
    for(int i = 0; i <= mn4t; ++i){
        ksprintf(s, "trace%d,", i);
    }
    s->s[s->l-1] = ']';
    ksprintf(s, ";\n");

    ksprintf(s, "var layout = {\n");
    ksprintf(s, " title: 'UMAP of single cells',\n");
    ksprintf(s, " showlegend: true,\n");
    ksprintf(s, " xaxis:{\n");
    ksprintf(s, "  automargin: true,\n");
    ksprintf(s, "  title:{\n");
    ksprintf(s, "    text: 'umap1',");
    ksprintf(s, "  },\n");
    ksprintf(s, " },\n");
    ksprintf(s, " yaxis:{\n");
    ksprintf(s, "  automargin: true,\n");
    ksprintf(s, "  title:{\n");
    ksprintf(s, "    text: 'uamp2',");
    ksprintf(s, "  },\n");
    ksprintf(s, " },\n");
    ksprintf(s, "};\n");

    ksprintf(s, "var config ={\n");
    ksprintf(s, "  toImageButtonOptions: {\n");
    ksprintf(s, "    format: 'svg',\n");
    ksprintf(s, "    filename: 'sc.umap.svg',\n");
    ksprintf(s, "    height: 800,\n");
    ksprintf(s, "    width: 800,\n");
    ksprintf(s, "    scale: 1,\n");
    ksprintf(s, "  }\n");
    ksprintf(s, "};\n");

    ksprintf(s, "Plotly.newPlot('plot_scumap', data, layout, config);\n");
    ksprintf(s, "</script>\n");
    // UMAP end
}

void scana_opt_t::html2foot(kstring_t* s){
    hmo.html2foot(s);
}

void scana_opt_t::ana4all(){
    init();
    htsFile* fp = bcf_open(inbcf.c_str(), "r");
    hts_idx_t* idx = bcf_index_load(inbcf.c_str());
    bcf_hdr_t* hdr = bcf_hdr_read(fp);
    int namp = 0;
    const char** amps = bcf_hdr_seqnames(hdr, &namp);
    scsc.resize(namp, SingleCellEditStatCountMap());
    ampcnts.resize(namp, NULL);
    // cell finder
    for(int i = 0; i < namp; ++i) amp4one(hdr, i);
    findc();
    cs2jsn();
    // amplicon~single_cell ana
    for(int i = 0; i < namp; ++i) ana4one(fp, idx, hdr, i);
    hts_close(fp);
    hts_idx_destroy(idx);
    FILE* a2sfp = fopen(ampalle4sctsv.c_str(), "w");
    fwrite(pa2s->s, sizeof(char), pa2s->l, a2sfp);
    fclose(a2sfp);
    free(pa2s->s); pa2s->s = NULL;
    // single_cell~amplicon ana
    ksprintf(ps2a, "Amplicon\tEditRate\tDepth\tStatus\tEditCells\tRefCells\tOtherCells\tValidCells");
    ksprintf(pe2a, "Amplicon");
    int e = 0, r = 0, o = 0, v = 0, n4t = 0, n4o = 0;
    for(auto& e: scwm){
        if(e.second->v){
            ksprintf(ps2a, "\t%s", e.first.c_str());
            ksprintf(pe2a, "\t%s", e.first.c_str());
        }
    }
    ksprintf(ps2a, "\n");
    ksprintf(pe2a, "\n");
    for(int i = 0; i < namp; ++i){
        ksprintf(ps2a, "%s\t%lf\t%d", amps[i], ampcnts[i]->edieff, ampcnts[i]->totcnt);
        ksprintf(pe2a, "%s", amps[i]);
        if(ampcnts[i]->isval) ksprintf(ps2a, "\tGood");
        else ksprintf(ps2a, "\tFail");
        e = r = o = v = 0;
        ptmp->l = 0;
        for(auto& s: scwm){
            if(!s.second->v) continue;
            auto iter = scsc[i].find(s.first);
            if(iter != scsc[i].end()){
                if(iter->second->v){
                    ksprintf(pe2a, "\t%lf", iter->second->ge);
                    if(iter->second->ge > minscedf){
                        ksprintf(ptmp, "\tE");
                        ++e;
                        ++v;
                    }else if(iter->second->go > minscotf){
                        ksprintf(ptmp, "\tO");
                        ++o;
                        ++v;
                    }else{
                        ksprintf(ptmp, "\tR");
                        ++r;
                        ++v;
                    }
                }else{
                    ksprintf(ptmp, "\tN");
                    ksprintf(pe2a, "\tNA");
                }
                ksprintf(ptmp, "(%d,%d,%d,%d)", iter->second->e, iter->second->r, iter->second->o, iter->second->d);
            }else{
                ksprintf(ptmp, "\tN");
                ksprintf(pe2a, "\tNA");
            }
        }
        ksprintf(ps2a, "\t%d\t%d\t%d\t%d%s\n", e, r, o, v, ptmp->l > 0 ? ptmp->s : "");
        ksprintf(pe2a, "\n");
    }
    // cell edit status on targets
    ksprintf(poes, "Cell\tonlyOneOnTargetEdit\ttotalOnTargetEdit\ttotalOffTargetEdit\n");
    for(auto& s: scwm){
        if(!s.second->v) continue;
        n4t = n4o = 0;
        for(int i = 0; i < namp; ++i){
            auto iter = scsc[i].find(s.first);
            if(iter != scsc[i].end()){
                if(iter->second->v){
                    if(iter->second->ge > minscedf){
                        if(ampcnts[i]->ison) ++n4t;
                        else ++n4o;
                    }
                }
            }
        }
        ksprintf(poes, "%s\t%d\t%d\t%d\n",
                       s.first.c_str(), 
                       n4t == 1 && n4o == 0 ? 1 : 0,
                       n4t, n4o);
    }
    FILE* ofp = fopen(ampcoedittsv.c_str(), "w");
    fwrite(ps2a->s, sizeof(char), ps2a->l, ofp);
    fclose(ofp);
    free(ps2a->s); ps2a->s = NULL;
    ofp = fopen(ampediteff4sc.c_str(), "w");
    fwrite(pe2a->s, sizeof(char), pe2a->l, ofp);
    fclose(ofp);
    free(pe2a->s); pe2a->s = NULL;
    ofp = fopen(otgedit4sc.c_str(), "w");
    fwrite(poes->s, sizeof(char), poes->l, ofp);
    fclose(ofp);
    umap();
    cs2html();
}

void scana_opt_t::amp4one(bcf_hdr_t* hdr, int i){
    int namp = 0, hidx = -1;
    const char* amp = bcf_hdr_seqnames(hdr, &namp)[i];
    int cid = bcf_hdr_id2int(hdr, BCF_DT_CTG, amp);
    bcf_hrec_t* hrec = bcf_hdr_id2hrec(hdr, BCF_DT_CTG, BCF_HL_CTG, cid);
    for(int k = 0; k < hrec->nkeys; ++k){
        if(hrec->keys[k][0] == 's'){
            char* pst = hrec->vals[k];
            int smax = 0, *sofs = 0;
            int snf = ksplit_core(pst, '-', &smax, &sofs);
            if(snf != 4){
                fprintf(stderr, "Error single cell barcode stats field parsed:%s!\n", pst);
                exit(EXIT_FAILURE);
            }
            sc_cnt_t* psc = (sc_cnt_t*)calloc(1, sizeof(sc_cnt_t));
            psc->d = atoi(pst+sofs[0]);
            psc->e = atoi(pst+sofs[1]);
            psc->r = atoi(pst+sofs[2]);
            psc->o = atoi(pst+sofs[3]);
            psc->a = psc->e+psc->r+psc->o;
            psc->ge = (double)psc->e/(double)(psc->a);
            psc->go = (double)psc->o/(double)(psc->a);
            psc->v = false;
            auto iter = scsc[i].find(hrec->keys[k]);
            if(iter == scsc[i].end()) scsc[i][hrec->keys[k]] = psc;
            else{
                fprintf(stderr, "Error, duplicate cell[%s] in amplicon[%s]!\n", hrec->keys[k], amp);
                exit(EXIT_FAILURE);
            }
            auto xitr = scwm.find(hrec->keys[k]);
            if(xitr == scwm.end()){
                sc_trec_t* ptt = (sc_trec_t*)calloc(1, sizeof(sc_trec_t));
                ptt->a = psc->a;
                ptt->v = false;
                ptt->onedited = false;
                scwm[hrec->keys[k]] = ptt;
            }else{
                xitr->second->a += psc->a;
            }
            for(int sni = 1; sni < snf; ++sni) pst[sofs[sni]-1] = '-'; // restore
        }
    }
    amp_cnt_t* pacnt = (amp_cnt_t*)calloc(1, sizeof(amp_cnt_t));
    hidx = bcf_hrec_find_key(hrec, "rawcnt");
    pacnt->rawcnt = atoi(hrec->vals[hidx]);
    hidx = bcf_hrec_find_key(hrec, "totcnt");
    pacnt->totcnt = atoi(hrec->vals[hidx]);
    hidx = bcf_hrec_find_key(hrec, "recstat");
    int recstat = atoi(hrec->vals[hidx]);
    hidx = bcf_hrec_find_key(hrec, "edieff");
    pacnt->edieff = atof(hrec->vals[hidx]);
    hidx = bcf_hrec_find_key(hrec, "muteff");
    pacnt->muteff = atof(hrec->vals[hidx]);
    if(recstat){
        hidx = bcf_hrec_find_key(hrec, "recpef");
        pacnt->recpef = atof(hrec->vals[hidx]);
        hidx = bcf_hrec_find_key(hrec, "receff");
        pacnt->receff = atof(hrec->vals[hidx]);
        hidx = bcf_hrec_find_key(hrec, "reeeff");
        pacnt->reeeff = atof(hrec->vals[hidx]);
    }
    pacnt->isval = pacnt->ison = false;
    if(otgs.find(amp) != otgs.end()) pacnt->ison = true;
    ampcnts[i] = pacnt;
}

void scana_opt_t::ana4one(htsFile* fp, hts_idx_t *idx, bcf_hdr_t *hdr, int i){
    int namp = 0, hidx = -1;
    const char* amp = bcf_hdr_seqnames(hdr, &namp)[i];
    int tid = bcf_hdr_name2id(hdr, amp);
    int cid = bcf_hdr_id2int(hdr, BCF_DT_CTG, amp);
    bcf_hrec_t* hrec = bcf_hdr_id2hrec(hdr, BCF_DT_CTG, BCF_HL_CTG, cid);
    hidx = bcf_hrec_find_key(hrec, "geb");
    int beg = atoi(hrec->vals[hidx]);
    hidx = bcf_hrec_find_key(hrec, "gee");
    int end = atoi(hrec->vals[hidx]);
    hts_itr_t* itr = bcf_itr_queryi(idx, tid, beg, end);
    bcf1_t* b = bcf_init1();
    int* vtv = NULL; float* afv = NULL; int* adv = NULL; char** scv = NULL;
    int nvt = 0, naf = 0, nad = 0, nsc = 0;
    int nsmp = bcf_hdr_nsamples(hdr);
    std::vector<sc_var_t*> vars;
    while(bcf_itr_next(fp, itr, b) >= 0){
        bcf_unpack(b, BCF_UN_INFO);
        if(bcf_get_info_int32(hdr, b, "VT", &vtv, &nvt) > 0){
            if(vtv[0] & type){
                bcf_unpack(b, BCF_UN_ALL);
                bcf_get_format_float(hdr, b, "AF", &afv, &naf);
                bcf_get_format_int32(hdr, b, "AD", &adv, &nad);
                bcf_get_format_string(hdr, b, "SC", &scv, &nsc);
                for(int a = 0; a < b->n_allele-1; ++a){
                    if(nsmp == 1 ||
                       (adv[a] > 0 && adv[nsmp*b->n_allele+a] < nctc)){
                        sc_var_t* v = new sc_var_t();
                        v->ref = b->d.allele[0];
                        v->alt = b->d.allele[a+1];
                        v->bfreq = afv[a];
                        v->bcnt = adv[a];
                        v->start = b->pos+1;
                        if(vtv[0] & (GEVAR_DEL | GEVAR_DIN)){
                            v->end = v->start + v->ref.size()-1;
                            v->start += 1;
                        }else if(vtv[0] & (GEVAR_SNV | GEVAR_INS)){
                            v->end = v->start;
                        }
                        v->width = (int)v->alt.size()-(int)v->ref.size();
                        v->type = GEV_STR_ARR[vtv[0]];
                        char* psc = scv[a];
                        int smax = 0, *sofs = 0;
                        int snf = ksplit_core(psc, '|', &smax, &sofs);
                        for(int sni = 0; sni < snf; ++sni){
                            char* psstr = psc+sofs[sni];
                            char* pcstr = strchr(psstr, '-');
                            int cbcnt = atoi(pcstr+1);
                            *pcstr = '\0';
                            if(scwm[psstr]->v) v->scnt[psstr] = cbcnt;
                        }
                        vars.push_back(v);
                    }
                }
            }
        }
    }
    // release ress
    if(afv){ free(afv); afv = NULL; }
    if(adv){ free(adv); adv = NULL; }
    if(vtv){ free(vtv); vtv = NULL; }
    if(scv){ free(scv[0]); free(scv); scv = NULL; }
    hts_itr_destroy(itr);
    bcf_destroy(b);
    bcf_hrec_destroy(hrec);
    // do single cell analysis
    std::sort(vars.begin(), vars.end(), ScVarSortByFreq());
    sc_var_t* psv = NULL;
    int outn = vars.size();
    if(outn > topn) outn = topn;
    for(int ni = 0; ni < outn; ++ni){
        psv = vars[ni];
        ptmp->l = 0;
        ksprintf(pa2s, "%s\t%s\t%s\t%d\t%f\t%d\t",
                       amp, 
                       psv->ref.c_str(),
                       psv->alt.c_str(),
                       psv->width,
                       psv->bfreq,
                       psv->bcnt);
        int n = 0;
        for(auto& p: psv->scnt){
            auto iter = scsc[i].find(p.first);
            if(iter == scsc[i].end()){
                fprintf(stderr, "cell[%s] of amplicon[%s] not in bcf header\n", p.first.c_str(), amp);
                exit(EXIT_FAILURE);
            }else{
                ksprintf(ptmp, "%s(%d/%d)|", p.first.c_str(), p.second, iter->second->a);
                ++n;
            }
        }
        if(n > 0){
            ptmp->s[ptmp->l-1] = '\0';
            ksprintf(pa2s, "%d\t%s\n", n, ptmp->s);
        }else{
            ksprintf(pa2s, "0\t-\n");
        }
    }
}

void scana_usage(scana_opt_t* opt, char* arg0){
    fprintf(stderr, "\n");
    fprintf(stderr, "Usage: %s %s [options]\n\n", PACKAGE_NAME, arg0);
    fprintf(stderr, "Options:  -i FILE  input bcf generated by getools\n");
    fprintf(stderr, "          -a FILE  on-target amplicon list\n");
    fprintf(stderr, "          -o STR   output file path prefix [%s]\n", opt->outdir.c_str());
    fprintf(stderr, "          -d INT   min average depth of each amplicon [%d]\n", opt->minavgd4amp);
    fprintf(stderr, "          -m FLOAT min frac of mean of mean amplicon depth(mmd) as valid amplicon/cell [%f]\n", opt->minf4meanr);
    fprintf(stderr, "          -p FLOAT min frac of amplicons must exceed mmd in one cell [%f]\n", opt->minf4vcell);
    fprintf(stderr, "          -e FLOAT amplicon/cell edit rate threshold to consider as edit type [%f]\n", opt->minscedf); 
    fprintf(stderr, "          -f FLOAT amplicon/cell others rate threshold to consider as other type [%f]\n", opt->minscotf); 
    fprintf(stderr, "          -n INT   number of top shared variants to output [%d]\n", opt->topn);
    fprintf(stderr, "          -v INT   masks of variant type to output(1:SNV,2:INSERTION,4:DELETION,8:DELINS) [%d]\n", opt->type);
    fprintf(stderr, "          -9 FILE js/css cdn configure json file\n");
    fprintf(stderr, "\n");
}

int scana_main(int argc, char** argv){
    scana_opt_t opt;
    if(argc == 1){
        scana_usage(&opt, argv[0]);
        return 0;
    }
    int c = 0;
    while((c = getopt(argc, argv, "i:a:o:d:m:p:f:e:n:v:9:h")) >= 0){
        switch(c){
            case 'i': opt.inbcf = optarg; break;
            case 'a': opt.otgl = optarg; break;
            case 'o': opt.outdir = optarg; break;
            case 'd': opt.minavgd4amp = atoi(optarg); break;
            case 'm': opt.minf4meanr = atof(optarg); break;
            case 'p': opt.minf4vcell = atof(optarg); break;
            case 'e': opt.minscedf = atof(optarg); break;
            case 'f': opt.minscotf = atof(optarg); break;
            case 'n': opt.topn = atoi(optarg); break;
            case 'v': opt.type = atoi(optarg); break;
            case '9': opt.hrjsn = optarg; break;
            case 'h': scana_usage(&opt, argv[0]); return 0; break;
            default: break;
        }
    }
    if(opt.valid()){
        opt.ana4all();
        return 0;
    }else{
        return 1;
    }
}
